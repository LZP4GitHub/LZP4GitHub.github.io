<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[类和面向对象]]></title>
    <url>%2F2020%2F05%2F18%2FPython_Feature_3%2F</url>
    <content type="text"><![CDATA[对象比较：is 与 ==id()（也就是内存地址）相同就可以is 当两个变量指向同一个对象即id相同时，is 表达式的结果为True 当各变量指向的对象含有相同内容时，==表达式的结果为True。 字符串转换待续]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>类</tag>
        <tag>对象</tag>
        <tag>namedtuple</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python整洁之道]]></title>
    <url>%2F2019%2F11%2F13%2FPython_Feature_1%2F</url>
    <content type="text"><![CDATA[断言 assert 使用示例 使用在线商城的打折券为例子： 1234def apply_discount(product,discount): price = int(product["price"] * (1.0 - discount)) assert 0 &lt;= price &lt;= product["price"] return price 下边创建一个实例： 123&gt;&gt;&gt; shoes = &#123;'name': "Fancy shoes" , "price": 13000&#125;&gt;&gt;&gt; apply_discount(shoes,0.2) # 通过 10400&gt;&gt;&gt; apply_discount(shoes,2) # 报错 报错信息指向： 12AssertionError:----&gt; 3 assert 0 &lt;= price &lt;= product[&quot;price&quot;] 故使用断言验证失败具体位置，便于异常回溯。断言是告诉coder程序中出现了不可恢复的错误，对于可以预测的错误（eg没有找到文件）不适用于断言。断言是程序内部自检，用于处理程序中不可能出现的条件，一旦不符合条件，就影响到后边的运算的正确性，所有断言是辅助调试工具。 断言语法assert 语句的语法是： 1assert_stmt ::= "assert" expression1 ["," expression2] 其中expression1是需要测试的条件，可选的expression2是错误信息。如果断言失败就会显示这个错误信息。在Python解释器中相当于： 123if _debug__: if not expression1: raise AssertionError(expression2) eg: 12345678910&gt;&gt;&gt; if cond == "x": do_X() elif cond == "y": do_Y() else: assert False, ( '这种情况一般不会出现,但偶尔会出现', '每次debug就不会出现这种情况了', '我也不知道原因，你可以给我发邮件', ) 注意事项 断言会给程序带来安全风险和bug。 容易形成语法怪癖，容易写出很多无用的断言。 不用断言验证数据如果命令行使用 -O 或者 -OO标识，或者修改了CPython的 PYTHONOPTIMIZE环境变量，就会全局禁用断言。如果用于判断管理员的断言被屏蔽，普通用户就有了管理员的权限。如果禁用断言引发了较大的错误，那么可能被其他人利用发起DoS攻击。可以使用if语句来代替此类断言。 不要用元组做断言条件元组作为assert的expression1的时候，断言总是真的。 1assert(1==2,"This shold fail") # Always True 因为Python中非空元组总是真值。有些错误更不容易被发现。如下例，不知不觉就用到了元组。 1234assert( counter == 10, "It also always true." ) Python断言总结断言是强大的调试工具，了解断言可以更好的维护和调试Python代码。 关键点 Python断言是一种测试某个条件的调试辅助功能，用于程序的内部自检。 断言应该用于帮助开发者识别bug，不是用于处理运行时的错误的机制。 设置解释器可以全局禁用断言。 逗号的使用在Python的列表、字典或者集合常量中添加或者移除项，记得在所有行后边加一个逗号。eg： 12345&gt;&gt;&gt; names = [ "Alice", "Bob", "Dog" ] 这里在Dog后边加上逗号比较好，这样如果在代码编辑的时候在后边加元素就不容易漏掉逗号了。否则就会有比较大的错误。 123456&gt;&gt;&gt; names = [ "Alice", "Bob", "Dog" "Kitty" ] 看起来是四个元素，但是由于字符串字面值拼接的原因，缺少了逗号后 12&gt;&gt;&gt; names ['Alice', 'Bob', 'DogKitty'] 后边两个拼接起来了，字符串拼接是一个特性。“以空白字符分隔多个相连的字符串或byte字面值，即使他们各自使用不同的引号，也会执行拼接操作。”字符串字面值拼接主要用于在跨越多行的长字符串之间可以省去反斜杠。那么在Python列表，字典，集合的最后一项后边也加上逗号就解决了。最后效果： 123456&gt;&gt;&gt; names = [ "Alice", "Bob", "Dog", "Kitty", ] 关键点 合理的逗号放置可以让列表、字典和集合更容易维护。 Pyton的字符串字面拼接特性即可能带来帮助，也会引发难以发现的bug。 上下文和with语句with使用方法再打开文件的时候经常使用 with open(file_path,&quot;r+&quot;) as f: 因为这样会在程序执行离开with语句的上下文后自动关闭。所以正常的文件操作可以理解为： 12345f = open(file_path,"r+")try: do_something_with(f);finally: f.close() 其实，只要类能够实现上下文管理器(context manager)，就可以与with一起使用了。上下文管理器也就是类方法中有__enter__和__exit___。Python会在进入with上下文的时候调用__enter__，离开with上下文的时候调用__exit___。 with用例文本缩进的例子：首先实现一个有上下文管理器的类： 12345678910111213class Indenter: def __init__(self): self.level = 0 def __enter__(self): self.level += 1 return self def __exit__(self,exc_type,exc_val,exc_tb): self.level -= 1 def print(self,text): print(" " * self.level + text + " num space: " + str(self.level)) 然后就可以使用with操作： 1234567with Indenter() as indent: indent.print("one") with indent: indent.print("two") with indent: indent.print("three") indent.print("last_one") 1234one num space: 1 two num space: 2 three num space: 3last_one num space: 1 关键要点 with语句就是通过在所谓的上下文管理器中封装try ... finally ...语句的标准用法来简化异常处理。 with语句一般用于管理系统资源的安全获取和释放。 下划线、双下划线 前置单下划线： _var 后置单下划线： var_ 前置双下划线： __var 前后双下划线： _var_ 单下划线： _ 前置单下划线作用只有提示作用，说明该变量或者方法只在内部使用。对Python解释器没有特殊含义。但是在一定情况下，如使用通配符导入的时候不会导入带有下划线的名称。（除非模块中定义了__all__列表覆盖了这种行为）eg: 无法使用 from my_module import * 导入my_module.py里定义的_my_func()方法，需要 12import my_module my_module._my_func() 后置下划线 var_主要用于防止与python关键字重复，多用于 class_等 前置双下划线 __var在类环境中使用会触发名称改写，对Python解释器有特殊含义。我一般不用这个，就不看了。 补充： dunder 即为 双下划线 （double underscore） ##前后双下划线前后双下划线不受Python解释器影响。双下划线方法为魔法方法。在自己的方法实现和变量中最好不要自定义这种类型，容易冲突，现在不冲突可能过两年python版本更新就冲突了。 ##单下划线 _单下划线用于名称时，可以表示变量是暂时的和无关紧要的，占位符一样。eg: 12345for _ in range(10): print("hello")car = ('red',"auto",332)color, _, _ = car _ 还可以在Python REPL中是一种特殊变量，表示解释器计算的上一个表达式的结果 123456&gt;&gt;&gt; 20 + 323&gt;&gt;&gt; _23&gt;&gt;&gt; print(_)23 字符串格式化%类型的1234567891011&gt;&gt;&gt; 'Hello, %s' % name'Hello Bob' &gt;&gt;&gt; 'Hey %&#123;name&#125;s ,there is a 0x%&#123;errno&#125;x error!' % &#123;"name":name,"errno":errno&#125;"Hey Bob,there is a 0xbadc0ffee error!"``` ## `format`形式 ```python&gt;&gt;&gt; 'Hello ,&#123;&#125;'.format(name)'Hello Bob'&gt;&gt;&gt; 'Hey &#123;name&#125; ,there is a 0x&#123;errno:x&#125; error!'.format(name=name,errno=errno)"Hey Bob,there is a 0xbadc0ffee error!" f&#39;&#39;形式（Python3.6+）字符串字面值插值 12345678910&gt;&gt;&gt; f'Hello &#123;name&#125;''Hello Bob' &gt;&gt;&gt; a = 5&gt;&gt;&gt; b = 10&gt;&gt;&gt; f'Five plus ten is &#123;a+b&#125; and not &#123;2*(a + b)&#125;.''Five plus ten is 15 and not 30.'&gt;&gt;&gt; f'Hey &#123;name&#125; ,there is a 0x&#123;errno:#x&#125; error!'"Hey Bob,there is a 0xbadc0ffee error!" 模板字符串12345678&gt;&gt;&gt; from string import Template&gt;&gt;&gt; t = Template("Hey,$name")&gt;&gt;&gt; t.substitute(name = name)'Hey,Bob'&gt;&gt;&gt; tmp1_string = 'Hey $name ,there is a $errno error!'&gt;&gt;&gt; Template(tmp1_string).substitute(name=name,errno=hex(errno))"Hey Bob,there is a 0xbadc0ffee error!" 模板字符串更简单也更加安全，处理用户输入的字符串的时候最好用Template]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>assert</tag>
        <tag>逗号</tag>
        <tag>上下文和with</tag>
        <tag>下划线</tag>
        <tag>string format</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数]]></title>
    <url>%2F2019%2F11%2F13%2FPython_Feature_2%2F</url>
    <content type="text"><![CDATA[函数是Python的头等对象函数是python的头等对象，可以将函数分配给变量、存储在数据结构中，作为参数传递给其他函数，甚至作为其他函数的返回值。下边举一个简单例子： 12345def yell(text): return text.upper() + "!"&gt;&gt;&gt; yell("hello")'HELLO!' 函数作为对象python程序中的所有数据都是由对象或对象之间的关系表示的。字符串、列表和模块等都是对象。函数也是对象。上例的 yell 函数也是对象，所有可以分配给另一个变量。 1&gt;&gt;&gt; bark = yell 这边没有调用，知识获取了 yell 引用的函数对象。再创建了一个指向该对象的名称 bark 。调用这个变量可执行相同的底层函数对象。 函数对象和其名称是相互独立的实体。删掉了函数的原始名称 yell ，使用另一个名称 bark 同样可以指向底层函数并调用。 12345678910111213&gt;&gt;&gt; del yell&gt;&gt;&gt; yell("hello")NameError:"name" 'yell' is not defined&gt;&gt;&gt; bark('Hey')"HEY!"``` 但是函数创建的时候仍然给每个函数附带了便于调试的字符串。使用__name__属性可以访问这个内部标识符：&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=yellow&gt;即便夺去了天下，也夺去不了你&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;```python&gt;&gt;&gt; bark.__name__'yell' 指向函数的变量和函数本身是相互独立的 函数存储在数据结构中eg: 1&gt;&gt;&gt; funcs = [bark,str.lower,str.capitalize] 可以直接调用 12&gt;&gt;&gt; funcs[0]("heyho")"HEYHO!" ##函数可以传递给其他函数func用于传递 123456def greet(func): greeting = func("Hi, I am a Python program") print(greeting)&gt;&gt;&gt; greet(bark)'HI, I AM A PYTHON PROGRAM' 这样就可以将函数的行为抽象出来并传递出去。而能接受其他函数作为参数的函数称为高阶函数。比如内置的 map 函数，map 函数接受一个函数对象和一个可迭代对象，然后将可迭代对象中的每个元素调用该函数。 12&gt;&gt;&gt; list(map(bark,['hello', 'hi', 'hey']))['HELLO!', 'HI!', "HEY!"] 函数可以嵌套eg: 1234567def speak(text): def whisper(t): return t.lower() + "..." return whisper(text)&gt;&gt;&gt; speak("Hello, World")'hello, world...' 这里whisper只在speak内部，无法直接调用，即便使用 speak.whisper 也不行。要想调用只能改成将内部的函数返回给父函数的调用者。 函数可以捕获局部状态内部函数不仅可以从父函数返回。还可以捕获并携带父函数的某些状态.eg: 123456789101112def get_speak_func(text,vol): def whisper(): return text.lower() + "..." def yell(): return text.upper() + "!" if vol &gt; 0.5: return yell else: return whisper&gt;&gt;&gt; get_speak_func('Hello, world',0.7)()'HELLO WORLD!' 这里的whisper和yell都没有text参数。但是内部函数仍然可以访问父函数中定义的text参数。它捕捉到并记住这个参数的值了。拥有这个行为的函数称为词法闭包（lexical closure），也叫闭包。闭包在程序流不在闭包范围内的情况下，也能记住封闭区域（enclosing scope）中的值。这意味着函数不仅可以返回行为，还可以预先配置这些行为。eg: 123456789101112def make_adder(n): def add(x): return x + n return add&gt;&gt;&gt; plus_3 = make_adder(3)&gt;&gt;&gt; plus_5 = make_adder(5)&gt;&gt;&gt; plus_5(4)9&gt;&gt;&gt; plus_3(4)7 这里make_adder作为工厂函数来创建和配置各种add函数。这些adder函数仍然能访问make_adder函数位于封闭区域中的参数n。 对象可以作为作为函数使用python所有函数都是对象。但是有些对象不是函数，但是可以调用。这时候不是函数的对象也可以当成函数来对待。 如果一个对象是可以调用的，意味着可以使用圆括号函数调用语法，甚至可以传入调用参数。这些都由_call_双下划线方法完成，下边的类能定义可调用对象： 123456789class Adder: def __init__(self,n): self.n = n def __call__(self,x): return self.n + x&gt;&gt;&gt; plus_3 = Adder(3)&gt;&gt;&gt; plus_3(4)7 像函数这样“调用”一个对象实例实际上就是执行该对象的__call__方法。当然不是所有的对象都可以被调用，可以使用内置的callable函数来检查一个对象能不能被调用。 123456&gt;&gt;&gt; callable(plus_3)True&gt;&gt;&gt; callable(yell)True&gt;&gt;&gt; callable("Hello")False python一起皆对象,函数也是对象，可以将函数分配给变量或者存储在数据结构中，作为头等对象，函数也可以被传递给其他函数或者作为其他函数的返回值 头等函数的特性可以用于抽象和传递程序中的行为 函数可以嵌套，并且捕捉并携带父函数的一些状态。具有这种行为的函数称为闭包。 对象可以被设置成可调用的，因此很多情况下可以将其作为函数对待。 lambda 单表达式函数python中的lambda关键词可以快速声明小型匿名函数。lambda函数的行为与使用 def 关键词声明的常规函数一样，可以用作所有需要函数对象的地方。eg: 123456&gt;&gt;&gt; add = lambda x, y : x + y&gt;&gt;&gt; add(3,5)8&gt;&gt;&gt; (lambda x, y : x + y)(3,5)8 概念上 lambda表达式 lambda x, y : x + y与使用def 声明函数相同，但是从语法来说表达式位于lambda内部。关键区分在于：lambda不必先将函数对象与名称（可以不要名称的）绑定，只需要在lambda中创建一个想要执行的表达式，然后像普通函数那样立即调用进行计算。而且lambda函数只能含有一个表达式，这意味着lambda函数不能使用语句或者注解（annotation）,甚至不能使用返回语句。只能是计算其中的表达式，然后自动返回表达式的结果作为返回值。也就是总有一个隐式的返回表达式。所有lambda还被叫做单表达式函数. lambda的应用场景应用场所很多，只要需要提供一个函数对象时都能用。可以用作可迭代对象的排序时，使用lambda表达式定义简短的key 函数： 12345&gt;&gt;&gt; tuples = [(1,'d'),(2,'b'),(4,'a'),(3,'c')]&gt;&gt;&gt; sorted(tuple, key = lambda x: x[1])[(4,'a'),(2,'b'),(3,'c'),(1,'d')]&gt;&gt;&gt; sorted(range(-5,6),key = lambda x:x*x)[0,-1,1,-2,2,-3,3,-4,4,-5,5] 上边两个例子可以更简洁的用oprator.itemgetter() 和 abs() 函数 lambda与普通嵌套函数一样具有词法闭包功能。 12345 def make_adder(n): return lambda x: x + n&gt;&gt;&gt; plus_3 = make_adder(3)&gt;&gt;&gt; plus_3(4)7 即使n在make_adder函数（封闭的作用域）中定义的，但是lambda函数仍然能访问n的值。 但是不要花哨的使用，在与map()或者filter()结合容易不好理解，这里可以用列表解析式或者生成表达式会清晰： 1234&gt;&gt;&gt; list(filter(lambda x: x % 2 == 0, range(12)))[0,2,4,6,8,10]&gt;&gt;&gt; [x for x in range(12) if(x % 2 == 0)] lambda 是单表达式函数，不必与名称绑定（匿名） lambda 函数不能呢个使用普通的Python语句，其中总是包含一个隐式的return 语句。 使用前考虑好使用普通具名函数或列表解析式是否更加清晰 装饰器 Python 的装饰器可以临时拓展和修改可调用对象（函数、方法和类）的行为，同时又不会永久修改可调用对象本身。 装饰器的一大用途就是将通用的功能应用到现有的类或函数的行为上，这些功能包括： 日志（logging） 访问控制与授权 衡量函数，如执行时间 限制访问速率（rate-limiting） 缓存，等等 回顾下函数特性： 函数是对象，可以分配给变量并传递给其他函数，以及从其他函数返回。函数内部也能定义函数，而且子函数可以捕获父函数的局部状态（闭包） 装饰器基础装饰器用来装饰另一个函数，在被包装函数运行之前和之后执行一些代码。装饰器是可调用的，将可调用对象作为输入并返回另一个可调用对象。eg： 123456789def null_decorator(func): return func@null_decoratordef greet(): return "Hello"&gt;&gt;&gt; greet()'Hello' 在函数定义前放置一个@null_decorator，相当于先定义这个函数，然后运行这个装饰器。@只是语法糖，简化了这种常用的写法。但是使用@语法在函数定义时就立即修饰该函数，这样不好访问未装饰的原函数了。如果想保留调用未装饰函数的能力，还需要手动修饰需要处理的函数。 装饰器可以修改行为实现一个有实际作用的装饰器 123456def uppercase(func): def wrap(): original_result = func() modified_result = original_result.upper() return modified_result return wrap 这个uppercase装饰器在内部定义了一个新函数（闭包）。在调用原函数时，新函数会包装原函数来修改其行为。包装闭包可以访问未经装饰的输入函数，并且在输入函数之前和之后自由执行额外的代码。 123456@uppercasedef greet(): return "Hello"&gt;&gt;&gt; greet()'HELLO' uppercase本身就是一个函数。对于被装饰的输入函数来说，修改其未来行为的唯一方法就是用闭包替换（或者包装）这个函数。装饰器通过包装闭包来修改可调用对象的行为，因此无需永久的修改原对象。原可调用对象的行为仅仅在装饰时才变化。所以大量可重用代码（日志输出等）应用于现有的函数与类就可以用装饰器来实现。 将多个装饰器应用到一个函数多个装饰器装饰一个函数的顺序是自下而上。也就是靠近函数的装饰器先装饰（近水楼台）。 ##装饰器接受参数的函数之前的装饰器都是只有一个函数输入，输出一个函数（函数都是地址，都没有实现的）。而如果要用到参数就要用到Python的变长参数*args和**kwargs 特性。 1234def proxy(func): def wrapper(*args,**kwargs): return func(*args,**kwargs) return wrapper 他在wrapper闭包定义使用*和**操作收集位置参数和关键词参数，并保存到args和kwargs里。 接着，wrapper闭包使用*和** 参数解包 操作符将收集到的参数转发到原输入函数。eg：trace装饰器可以记录函数参数和结果： 12345678910111213141516171819def trace(func): def wrapper(*args,**kwargs): print(f'TRACE: calling &#123;func.__name__&#125;()' f'with &#123;args&#125;,&#123;kwargs&#125;') original_result = func(*args,**kwargs) print(f'TRACE: &#123;func.__name__&#125;() ' f'returned &#123;original_result&#125;') return original_result return wrapperIn [2]: @trace ...: def say(name,line): ...: return f'&#123;name&#125;:&#123;line&#125;' ...:In [3]: say('lzp','Hello World!')TRACE: calling say()with ('lzp', 'Hello World!'),&#123;&#125;TRACE: say() returned lzp:Hello World!Out[3]: 'lzp:Hello World! ‘可调试’的装饰器使用装饰器其实是用一个函数替代另一个函数，这个过程有个缺点就是“隐藏了”原函数附带的一些元数据。如果装饰之后，__name__ 和 _doc_ 都是闭包的元数据。但是使用python标准库的 @functools.wraps 能够将缺失的元数据复制到装饰器的闭包中。 1234567import functoolsdef uppercase(func): @functools.wraps(func) def wrapper(): return func.upper() return wrapper 将functools.wraps 应用到由装饰器返回的封装闭包中，会获得原函数的文档字符串和其他元数据： 1234567891011In [7]: @uppercase ...: def greet(): ...: """Rerturn a friendly greeding""" ...: return "HELLO" ...:In [8]: greet.__name__Out[8]: 'greet'In [9]: greet.__doc__Out[9]: 'Rerturn a friendly greeding' ##关键点 装饰器定义可重用组件。用于可调用对象改变其行为，同时无需永远修改可调用对象本身。 @语法只是在输入函数上调用装饰器对的简写。单个函数应用多个装饰器是从下而上的。 可以使用functools.wraps 将被装饰对象中的元数 据转移到装饰后的对象中。 *args 和 **kwargs*args 和**kwargs 参数到底有什么用呢？它们能让函数接受可选参数，因此能在模块和类中创建灵活的API： 123456def foo(required,*args,**kwargs): print(required) if args: print(args) if kwargs: print(kwargs) 上述函数至少需要一个名为required 的参数，但也可以接受额外的位置参数和关键字参数。如果用额外的参数调用该函数，args 将收集额外的位置参数组成元组，因为这个参数名称带有*前缀。同样，kwargs 会收集额外的关键字参数来组成字典，因为参数名称带有**前缀。如果不传递额外的参数，那么args 和kwargs 都为空。 1234&gt;&gt;&gt; foo('hello', 1, 2, 3, key1='value', key2=999)hello(1, 2, 3)&#123;'key1': 'value', 'key2': 999&#125; 参数在传递之前还可以修改: 1234def foo(x, *args, **kwargs): kwargs['name'] = 'Alice' new_args = args + ('extra', ) bar(x, *new_args, **kwargs) 传递可选参数或关键词参数可选参数或关键字参数还可以从一个函数传递到另一个函数。这需要用解包操作符 * 和 ** 将参数传递给被调用的函数。这种技术适用于创建子类和编写包装函数。例如在扩展父类的行为时，子类中的构造函数不用再带有完整的参数列表，因而适用于处理那些不受我们控制的API： 12345678910class Car: def __init__(self, color, mileage): self.color = color self.mileage = mileageclass AlwaysBlueCar(Car): def __init__(self,*args,**kwargs): super().__init__(*args,**kwargs) self.color = 'Blue'&gt;&gt;&gt; AlwaysBlueCar('green', 48392).color'Blue' AlwaysBlueCar 构造函数只是将所有参数传递给它的父类，然后重写一个内部属性。这意味着如果父类的构造函数发生变化，AlwaysBlueCar 仍然可以按预期运行。不过缺点是，AlwaysBlueCar 构造函数现在有一个相当无用的签名——若不查看父类，无从知晓函数会接受哪些参数。一般情况下，自己定义的类层次中并不会用到这种技术。这通常用于修改或覆盖某些外部类中的行为，而自己又无法控制这些外部类。还可以在装饰函数中传递函数参数。 123456789101112131415import functoolsdef trace(f): @functools.wraps(f) def decorated_function(*args,**kwargs): print(f,args,kwargs) original_result = f(*args,**kwargs) print(original_result) return decorated_function@trace def greet(greeting,name): return '&#123;&#125;, &#123;&#125;!'.format(greeting, name)In [12]: greet('Hello','Mike')&lt;function greet at 0x2ace01b711e0&gt; ('Hello', 'Mike') &#123;&#125;Hello, Mike! 关键要点 *args 和**kwargs 用于在Python 中编写变长参数的函数。 *args 收集额外的位置参数组成元组。**kwargs 收集额外的关键字参数组成字典。 实际起作用的语法是*和**。args 和kwargs 只是约定俗成的名称（但应该坚持使用这两个名称）。 函数参数解包* 和** 操作符可以分别从序列（包含元组等）和字典中“解包”函数参数。123456789def print_vector(x, y, z): print('&lt;%s, %s, %s&gt;' % (x, y, z))&gt;&gt;&gt; tuple_vec = (1, 0, 1)&gt;&gt;&gt; list_vec = [1, 0, 1]&gt;&gt;&gt; print_vector( tuple_vec[0], tuple_vec[1], tuple_vec[2])&lt;1, 0, 1&gt; 这样加入多个参数太麻烦，怎样将向量参数炸开成三个组件就好了。 12print_vector(*tuple_vec)print_vector(*list_vec) 在函数调用时，在可迭代对象前面放一个*能解包这个参数，将其中的元素作为单独的位置参数传递给被调用的函数。这种技术适用于任何可迭代对象，包括生成器表达式。在生成器上使用*操作符会消耗生成器中的所有元素，并将它们传递给函数： 12345678&gt;&gt;&gt;genexpr = (x*x for x in range(3))&gt;&gt;&gt;print_vector(*genexpr)``` \*操作符用于将元组、列表和生成器等序列解包为位置参数。除此之外，还有用于从字典中解包关键字参数的\*\*操作符。假设用下面这个字典对象表示前面的向量：```python&gt;&gt;&gt; dict_vec = &#123;'y': 0, 'z': 1, 'x': 1&#125;&gt;&gt;&gt; print_vector(**dict_vec)&lt;1, 0, 1&gt; 由于字典是无序的，因此解包时会匹配字典键和函数参数：x 参数接受字典中与’x’键相关联的值。如果使用单个星号（*）操作符来解包字典，则所有的键将以随机顺序传递给函数： 12&gt;&gt;&gt; print_vector(*dict_vec)&lt;y, x, z&gt; Python 的函数参数解包功能带来了很多灵活性。也就是说，不一定要为程序所需的数据类型实现一个类，使用简单的内置数据结构（如元组或列表）就足够了，这样有助于降低代码的复杂度。 关键要点 * 和 ** 操作符可以从序列和字典中“解包”函数参数。 高效使用参数解包可以为模块和函数编写更灵活的接口。 默认返回空值Python在所以函数的末尾都添加了隐式的 return None 语句。所以函数没有指定返回值，默认就返回None。不写 return 相当于单语句 return 相当于 return None]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>函数</tag>
        <tag>lambda</tag>
        <tag>装饰器</tag>
        <tag>函数参数*args,**kwargs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 39 -- Combination Sum]]></title>
    <url>%2F2019%2F10%2F21%2FLeetcode-39%2F</url>
    <content type="text"><![CDATA[Discription Category Difficulty Likes Dislikes algorithms Medium (50.43%) 2565 78 Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.The same repeated number may be chosen from candidates unlimited number of times. Notes All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1123456Input: candidates = [2,3,6,7], target = 7,A solution set is:[ [7], [2,2,3]] Example 21234567Input: candidates = [2,3,5], target = 8,A solution set is:[ [2,2,2,2], [2,3,3], [3,5]] SolutionHere we use tree.Each node subtracts the elements of the array until the value of node is lower than 0.Reduce redundant.(the subtracts of lower node is large or equal to lower node) Code123456789101112131415161718192021222324252627282930## @lc app=leetcode id=39 lang=python## [39] Combination Sum## @lc code=startclass Solution(object): def combinationSum(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ candidates.sort() len_target = len(candidates) res = [] def find_sum(start,list_now,target_now): if(target_now == 0): res.append(list_now[:]) else: for i in range(start,len_target): if(target_now - candidates[i]&lt;0): continue else: list_now.append(candidates[i]) find_sum(i,list_now,target_now - candidates[i]) list_now.pop() find_sum(0,[],target) return res Result Accepted 168/168 cases passed (48 ms) Your runtime beats 72.65 % of python submissions Your memory usage beats 59.18 % of python submissions (11.8 MB)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>backtracking</tag>
        <tag>snapchat</tag>
        <tag>uber</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[就是测试下左下角的妹子]]></title>
    <url>%2F2019%2F09%2F15%2FTest-blog%2F</url>
    <content type="text"><![CDATA[一些参考博客： 曹雪松de博客 arccode]]></content>
      <tags>
        <tag>妹子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
