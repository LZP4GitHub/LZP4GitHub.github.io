<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python整洁之道]]></title>
    <url>%2F2019%2F11%2F13%2FPython%E7%89%B9%E6%80%A7(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[断言 assert 使用示例 使用在线商城的打折券为例子： 1234def apply_discount(product,discount): price = int(product["price"] * (1.0 - discount)) assert 0 &lt;= price &lt;= product["price"] return price 下边创建一个实例： 123&gt;&gt;&gt; shoes = &#123;'name': "Fancy shoes" , "price": 13000&#125;&gt;&gt;&gt; apply_discount(shoes,0.2) # 通过 10400&gt;&gt;&gt; apply_discount(shoes,2) # 报错 报错信息指向： 12AssertionError:----&gt; 3 assert 0 &lt;= price &lt;= product[&quot;price&quot;] 故使用断言验证失败具体位置，便于异常回溯。断言是告诉coder程序中出现了不可恢复的错误，对于可以预测的错误（eg没有找到文件）不适用于断言。断言是程序内部自检，用于处理程序中不可能出现的条件，一旦不符合条件，就影响到后边的运算的正确性，所有断言是辅助调试工具。 断言语法assert 语句的语法是： 1assert_stmt ::= "assert" expression1 ["," expression2] 其中expression1 是需要测试的条件，可选的expression2是错误信息。如果断言失败就会显示这个错误信息。在Python解释器中相当于： 123if _debug__: if not expression1: raise AssertionError(expression2) eg: 12345678910&gt;&gt;&gt; if cond == "x": do_X() elif cond == "y": do_Y() else: assert False, ( '这种情况一般不会出现,但偶尔会出现', '每次debug就不会出现这种情况了', '我也不知道原因，你可以给我发邮件', ) 注意事项 断言会给程序带来安全风险和bug 容易形成语法怪癖，容易写出很多无用的断言。 不用断言验证数据如果命令行使用 -O 或者 -OO标识，或者修改了CPython的 PYTHONOPTIMIZE环境变量，就会全局禁用断言。如果用于判断管理员的断言被屏蔽，普通用户就有了管理员的权限。如果禁用断言引发了较大的错误，那么可能被其他人利用发起DoS攻击。可以使用if语句来代替此类断言 不要用元组做断言条件元组作为assert的expression1的时候，断言总是真的。 1assert(1==2,"This shold fail") # Always True 因为Python中非空元组总是真值。有些错误更不容易被发现。如下例，不知不觉就用到了元组。 1234assert( counter == 10, "It also always true." ) Python断言总结断言是强大的调试工具，了解断言可以更好的维护和调试Python代码。 关键点 Python断言是一种测试某个条件的调试辅助功能，用于程序的内部自检。 断言应该用于帮助开发者识别bug，不是用于处理运行时的错误的机制。 设置解释器可以全局禁用断言。 逗号的使用在Python的列表、字典或者集合常量中添加或者移除项，记得在所有行后边加一个逗号。eg： 12345&gt;&gt;&gt; names = [ "Alice", "Bob", "Dog" ] 这里在Dog后边加上逗号比较好，这样如果在代码编辑的时候在后边加元素就不容易漏掉逗号了。否则就会有比较大的错误。 123456&gt;&gt;&gt; names = [ "Alice", "Bob", "Dog" "Kitty" ] 看起来是四个元素，但是由于字符串字面值拼接的原因，缺少了逗号后 12&gt;&gt;&gt; names [&apos;Alice&apos;, &apos;Bob&apos;, &apos;DogKitty&apos;] 后边两个拼接起来了，字符串拼接是一个特性。“以空白字符分隔多个相连的字符串或byte字面值，即使他们各自使用不同的引号，也会执行拼接操作。”字符串字面值拼接主要用于在跨越多行的长字符串之间可以省去反斜杠。那么在Python列表，字典，集合的最后一项后边也加上逗号就解决了。最后效果： 123456&gt;&gt;&gt; names = [ "Alice", "Bob", "Dog", "Kitty", ] 关键点 合理的逗号放置可以让列表、字典和集合更容易维护。 Pyton的字符串字面拼接特性即可能带来帮助，也会引发难以发现的bug。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>assert</tag>
        <tag>逗号</tag>
        <tag>上下文和with</tag>
        <tag>下划线</tag>
        <tag>string format</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 39 -- Combination Sum]]></title>
    <url>%2F2019%2F10%2F21%2FLeetcode-39%2F</url>
    <content type="text"><![CDATA[Discription Category Difficulty Likes Dislikes algorithms Medium (50.43%) 2565 78 Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.The same repeated number may be chosen from candidates unlimited number of times. Notes All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1123456Input: candidates = [2,3,6,7], target = 7,A solution set is:[ [7], [2,2,3]] Example 21234567Input: candidates = [2,3,5], target = 8,A solution set is:[ [2,2,2,2], [2,3,3], [3,5]] SolutionHere we use tree.Each node subtracts the elements of the array until the value of node is lower than 0.Reduce redundant.(the subtracts of lower node is large or equal to lower node) Code123456789101112131415161718192021222324252627282930## @lc app=leetcode id=39 lang=python## [39] Combination Sum## @lc code=startclass Solution(object): def combinationSum(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ candidates.sort() len_target = len(candidates) res = [] def find_sum(start,list_now,target_now): if(target_now == 0): res.append(list_now[:]) else: for i in range(start,len_target): if(target_now - candidates[i]&lt;0): continue else: list_now.append(candidates[i]) find_sum(i,list_now,target_now - candidates[i]) list_now.pop() find_sum(0,[],target) return res Result Accepted 168/168 cases passed (48 ms) Your runtime beats 72.65 % of python submissions Your memory usage beats 59.18 % of python submissions (11.8 MB)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>backtracking</tag>
        <tag>snapchat</tag>
        <tag>uber</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[就是测试下左下角的妹子]]></title>
    <url>%2F2019%2F09%2F15%2FTest-blog%2F</url>
    <content type="text"><![CDATA[一些参考博客： 曹雪松de博客 arccode]]></content>
      <tags>
        <tag>妹子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
