<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python整洁之道]]></title>
    <url>%2F2019%2F11%2F13%2FPython%E7%89%B9%E6%80%A7(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[断言 assert 使用示例 使用在线商城的打折券为例子： 1234def apply_discount(product,discount): price = int(product["price"] * (1.0 - discount)) assert 0 &lt;= price &lt;= product["price"] return price 下边创建一个实例： 123&gt;&gt;&gt; shoes = &#123;'name': "Fancy shoes" , "price": 13000&#125;&gt;&gt;&gt; apply_discount(shoes,0.2) # 通过 10400&gt;&gt;&gt; apply_discount(shoes,2) # 报错 报错信息指向： 12AssertionError:----&gt; 3 assert 0 &lt;= price &lt;= product[&quot;price&quot;] 故使用断言验证失败具体位置，便于异常回溯。断言是告诉coder程序中出现了不可恢复的错误，对于可以预测的错误（eg没有找到文件）不适用于断言。断言是程序内部自检，用于处理程序中不可能出现的条件，一旦不符合条件，就影响到后边的运算的正确性，所有断言是辅助调试工具。 断言语法assert 语句的语法是： 1assert_stmt ::= "assert" expression1 ["," expression2] 其中expression1是需要测试的条件，可选的expression2是错误信息。如果断言失败就会显示这个错误信息。在Python解释器中相当于： 123if _debug__: if not expression1: raise AssertionError(expression2) eg: 12345678910&gt;&gt;&gt; if cond == "x": do_X() elif cond == "y": do_Y() else: assert False, ( '这种情况一般不会出现,但偶尔会出现', '每次debug就不会出现这种情况了', '我也不知道原因，你可以给我发邮件', ) 注意事项 断言会给程序带来安全风险和bug。 容易形成语法怪癖，容易写出很多无用的断言。 不用断言验证数据如果命令行使用 -O 或者 -OO标识，或者修改了CPython的 PYTHONOPTIMIZE环境变量，就会全局禁用断言。如果用于判断管理员的断言被屏蔽，普通用户就有了管理员的权限。如果禁用断言引发了较大的错误，那么可能被其他人利用发起DoS攻击。可以使用if语句来代替此类断言。 不要用元组做断言条件元组作为assert的expression1的时候，断言总是真的。 1assert(1==2,"This shold fail") # Always True 因为Python中非空元组总是真值。有些错误更不容易被发现。如下例，不知不觉就用到了元组。 1234assert( counter == 10, "It also always true." ) Python断言总结断言是强大的调试工具，了解断言可以更好的维护和调试Python代码。 关键点 Python断言是一种测试某个条件的调试辅助功能，用于程序的内部自检。 断言应该用于帮助开发者识别bug，不是用于处理运行时的错误的机制。 设置解释器可以全局禁用断言。 逗号的使用在Python的列表、字典或者集合常量中添加或者移除项，记得在所有行后边加一个逗号。eg： 12345&gt;&gt;&gt; names = [ "Alice", "Bob", "Dog" ] 这里在Dog后边加上逗号比较好，这样如果在代码编辑的时候在后边加元素就不容易漏掉逗号了。否则就会有比较大的错误。 123456&gt;&gt;&gt; names = [ "Alice", "Bob", "Dog" "Kitty" ] 看起来是四个元素，但是由于字符串字面值拼接的原因，缺少了逗号后 12&gt;&gt;&gt; names ['Alice', 'Bob', 'DogKitty'] 后边两个拼接起来了，字符串拼接是一个特性。“以空白字符分隔多个相连的字符串或byte字面值，即使他们各自使用不同的引号，也会执行拼接操作。”字符串字面值拼接主要用于在跨越多行的长字符串之间可以省去反斜杠。那么在Python列表，字典，集合的最后一项后边也加上逗号就解决了。最后效果： 123456&gt;&gt;&gt; names = [ "Alice", "Bob", "Dog", "Kitty", ] 关键点 合理的逗号放置可以让列表、字典和集合更容易维护。 Pyton的字符串字面拼接特性即可能带来帮助，也会引发难以发现的bug。 上下文和with语句with使用方法再打开文件的时候经常使用 with open(file_path,&quot;r+&quot;) as f: 因为这样会在程序执行离开with语句的上下文后自动关闭。所以正常的文件操作可以理解为： 12345f = open(file_path,"r+")try: do_something_with(f);finally: f.close() 其实，只要类能够实现上下文管理器(context manager)，就可以与with一起使用了。上下文管理器也就是类方法中有__enter__和__exit___。Python会在进入with上下文的时候调用__enter__，离开with上下文的时候调用__exit___。 with用例文本缩进的例子：首先实现一个有上下文管理器的类： 12345678910111213class Indenter: def __init__(self): self.level = 0 def __enter__(self): self.level += 1 return self def __exit__(self,exc_type,exc_val,exc_tb): self.level -= 1 def print(self,text): print(" " * self.level + text + " num space: " + str(self.level)) 然后就可以使用with操作： 1234567with Indenter() as indent: indent.print("one") with indent: indent.print("two") with indent: indent.print("three") indent.print("last_one") 1234one num space: 1 two num space: 2 three num space: 3last_one num space: 1 关键要点 with语句就是通过在所谓的上下文管理器中封装try ... finally ...语句的标准用法来简化异常处理。 with语句一般用于管理系统资源的安全获取和释放。 下划线、双下划线 前置单下划线： _var 后置单下划线： var_ 前置双下划线： __var 前后双下划线： _var_ 单下划线： _ 前置单下划线作用只有提示作用，说明该变量或者方法只在内部使用。对Python解释器没有特殊含义。但是在一定情况下，如使用通配符导入的时候不会导入带有下划线的名称。（除非模块中定义了__all__列表覆盖了这种行为）eg: 无法使用 from my_module import * 导入my_module.py里定义的_my_func()方法，需要 12import my_module my_module._my_func() 后置下划线 var_主要用于防止与python关键字重复，多用于 class_等 前置双下划线 __var在类环境中使用会触发名称改写，对Python解释器有特殊含义。我一般不用这个，就不看了。 补充： dunder 即为 双下划线 （double underscore） ##前后双下划线前后双下划线不受Python解释器影响。双下划线方法为魔法方法。在自己的方法实现和变量中最好不要自定义这种类型，容易冲突，现在不冲突可能过两年python版本更新就冲突了。 ##单下划线 _单下划线用于名称时，可以表示变量是暂时的和无关紧要的，占位符一样。eg: 12345for _ in range(10): print("hello")car = ('red',"auto",332)color, _, _ = car _ 还可以在Python REPL中是一种特殊变量，表示解释器计算的上一个表达式的结果 123456&gt;&gt;&gt; 20 + 323&gt;&gt;&gt; _23&gt;&gt;&gt; print(_)23 字符串格式化%类型的1234567891011&gt;&gt;&gt; 'Hello, %s' % name'Hello Bob' &gt;&gt;&gt; 'Hey %&#123;name&#125;s ,there is a 0x%&#123;errno&#125;x error!' % &#123;"name":name,"errno":errno&#125;"Hey Bob,there is a 0xbadc0ffee error!"``` ## `format`形式 ```python&gt;&gt;&gt; 'Hello ,&#123;&#125;'.format(name)'Hello Bob'&gt;&gt;&gt; 'Hey &#123;name&#125; ,there is a 0x&#123;errno:x&#125; error!'.format(name=name,errno=errno)"Hey Bob,there is a 0xbadc0ffee error!" f&#39;&#39;形式（Python3.6+）字符串字面值插值 12345678910&gt;&gt;&gt; f'Hello &#123;name&#125;''Hello Bob' &gt;&gt;&gt; a = 5&gt;&gt;&gt; b = 10&gt;&gt;&gt; f'Five plus ten is &#123;a+b&#125; and not &#123;2*(a + b)&#125;.''Five plus ten is 15 and not 30.'&gt;&gt;&gt; f'Hey &#123;name&#125; ,there is a 0x&#123;errno:#x&#125; error!'"Hey Bob,there is a 0xbadc0ffee error!" 模板字符串12345678&gt;&gt;&gt; from string import Template&gt;&gt;&gt; t = Template("Hey,$name")&gt;&gt;&gt; t.substitute(name = name)'Hey,Bob'&gt;&gt;&gt; tmp1_string = 'Hey $name ,there is a $errno error!'&gt;&gt;&gt; Template(tmp1_string).substitute(name=name,errno=hex(errno))"Hey Bob,there is a 0xbadc0ffee error!" 模板字符串更简单也更加安全，处理用户输入的字符串的时候最好用Template]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>assert</tag>
        <tag>逗号</tag>
        <tag>上下文和with</tag>
        <tag>下划线</tag>
        <tag>string format</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 39 -- Combination Sum]]></title>
    <url>%2F2019%2F10%2F21%2FLeetcode-39%2F</url>
    <content type="text"><![CDATA[Discription Category Difficulty Likes Dislikes algorithms Medium (50.43%) 2565 78 Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.The same repeated number may be chosen from candidates unlimited number of times. Notes All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1123456Input: candidates = [2,3,6,7], target = 7,A solution set is:[ [7], [2,2,3]] Example 21234567Input: candidates = [2,3,5], target = 8,A solution set is:[ [2,2,2,2], [2,3,3], [3,5]] SolutionHere we use tree.Each node subtracts the elements of the array until the value of node is lower than 0.Reduce redundant.(the subtracts of lower node is large or equal to lower node) Code123456789101112131415161718192021222324252627282930## @lc app=leetcode id=39 lang=python## [39] Combination Sum## @lc code=startclass Solution(object): def combinationSum(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ candidates.sort() len_target = len(candidates) res = [] def find_sum(start,list_now,target_now): if(target_now == 0): res.append(list_now[:]) else: for i in range(start,len_target): if(target_now - candidates[i]&lt;0): continue else: list_now.append(candidates[i]) find_sum(i,list_now,target_now - candidates[i]) list_now.pop() find_sum(0,[],target) return res Result Accepted 168/168 cases passed (48 ms) Your runtime beats 72.65 % of python submissions Your memory usage beats 59.18 % of python submissions (11.8 MB)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>backtracking</tag>
        <tag>snapchat</tag>
        <tag>uber</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[就是测试下左下角的妹子]]></title>
    <url>%2F2019%2F09%2F15%2FTest-blog%2F</url>
    <content type="text"><![CDATA[一些参考博客： 曹雪松de博客 arccode]]></content>
      <tags>
        <tag>妹子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
